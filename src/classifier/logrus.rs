// (C) Copyright 2019 Hewlett Packard Enterprise Development LP

use std::collections::HashSet;

use crate::parser::Message;
use super::types::*;

static LOGRUS_MAPPED_FIELDS: &[&str] = &["msg", "time", "level"];
static LOGRUS_METADATA_FIELDS: &[&str] = &["file", "func"];

static FUNC_FIELD: &str = "func";

/// determines if this message was generated by logrus, based on the default
/// json output from its JSONFormatter with SetReportCaller(true)
/// this is admittedly quite fuzzy
fn is_logrus(message: &Message) -> bool {
  for field in LOGRUS_MAPPED_FIELDS {
    if !message.mapped_fields.contains_key(*field) {
      return false;
    }
  }

  for field in LOGRUS_METADATA_FIELDS {
    if !message.metadata.contains_key(*field) {
      return false;
    }
  }

  true
}

pub fn classify_logrus(
  message: &Message, fields: &mut HashSet<String>
) -> Vec<Chunk> {
  if !is_logrus(message) {
    return vec![];
  }
  
  // just hide the func field
  // it's less useful than file (which has a line number) and more difficult to
  // intuitively shorten
  if message.metadata.contains_key(FUNC_FIELD) {
    fields.insert(FUNC_FIELD.to_string());
  }

  // the generic context classifier can grab file/caller

  vec![]
}
