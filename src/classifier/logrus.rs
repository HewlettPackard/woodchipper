// (C) Copyright 2019 Hewlett Packard Enterprise Development LP

use std::collections::HashSet;

use crate::parser::Message;
use super::types::*;
use super::util::clean_path;

static LOGRUS_MAPPED_FIELDS: &[&str] = &["msg", "time", "level"];
static LOGRUS_METADATA_FIELDS: &[&str] = &["file", "func"];

static FILE_FIELD: &str = "file";
static FUNC_FIELD: &str = "func";

/// determines if this message was generated by logrus, based on the default
/// json output from its JSONFormatter with SetReportCaller(true)
/// this is admittedly quite fuzzy
fn is_logrus(message: &Message) -> bool {
  for field in LOGRUS_MAPPED_FIELDS {
    if !message.mapped_fields.contains_key(*field) {
      return false;
    }
  }

  for field in LOGRUS_METADATA_FIELDS {
    if !message.metadata.contains_key(*field) {
      return false;
    }
  }

  true
}

fn extract_file(message: &Message) -> Option<Chunk> {
  let path = match message.metadata.get(FILE_FIELD).and_then(|f| f.as_str()) {
    Some(path) => clean_path(path),
    None => return None
  };

  Some(Chunk {
    kind: ChunkKind::Context,
    slot: ChunkSlot::Right,
    alignment: ChunkAlignment::Right,
    weight: ChunkWeight::Low.value(),

    value: Some(path),

    pad_left: true,
    pad_right: true,
    force_break_after: true,

    ..Default::default()
  })
}

pub fn classify_logrus(message: &Message, fields: &mut HashSet<String>) -> Vec<Chunk> {
  let mut ret: Vec<Chunk> = Vec::new();
  if !is_logrus(message) {
    return ret;
  }
  
  // just hide the func field
  // it's less useful than file (which has a line number) and more difficult to
  // intuitively shorten
  if message.metadata.contains_key(FUNC_FIELD) {
    fields.insert(FUNC_FIELD.to_string());
  }

  if let Some(file) = extract_file(message) {
    ret.push(file);
    fields.insert(FILE_FIELD.to_string());
  }

  ret
}
